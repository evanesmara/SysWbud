/******************************************************************************
 *
 * Copyright:
 *    (C) 2000 - 2005 Embedded Artists AB
 *
 * Description:
 *
 * ESIC:
 *    pre_emptive_os
 *
 * Version:
 *    1.4.0
 *
 * Generate date:
 *    2005-03-15 at 20:27:15
 *
 * NOTE:
 *    DO NOT EDIT THIS FILE. IT IS AUTO GENERATED.
 *    CHANGES TO THIS FILE WILL BE LOST IF THE FILE IS RE-GENERATED
 *
 * Signature:
 *   7072655F656D70746976655F6F73,312E342E302E30,020235
 *   ,35,10104021013134373435363030,07323838,3732,01013
 *   830,0101013138303030303030,3135,33,3135,0232323530
 *   ,01020130,0231343734353539,3238313831,020101100302
 *   103030310010133,0163130,3230,3330,3430,3530,3630,3
 *   730,3830,3930,313030,313130,313230,313330,313430,3
 *   13530,313630,,35,35,35,35,35,35,35,35,35,35,35,35,
 *   35,35,35,35,,,,1001001100011000000000]484152445741
 *   5245,4C5043323130365F32,545538,756E7369676E6564206
 *   3686172,414C49474E4D454E54,34,54424F4F4C,756E73696
 *   76E65642063686172,54553332,756E7369676E656420696E7
 *   4,544D505F46494C4553,2A2E656C663B2A2E6C73743B2A2E6
 *   D61703B2A2E6F3B2A2E6F626A3B2A2E64,454E4449414E,4C4
 *   954544C45,54533332,7369676E656420696E74,545338,736
 *   9676E65642063686172,54553136,756E7369676E656420736
 *   86F7274,54533136,7369676E65642073686F7274,44455343
 *   52495054494F4E,,44454255475F4C4556454C,30,434F4445
 *   5F524F4F54,,47454E5F52554C4553,,4C494E455F5445524D
 *   ,43524C46,4252414345,,43524541544F52,416E646572732
 *   0526F7376616C6C,4352454154494F4E5F44415445,3230303
 *   52D30332D31352032303A31373A3432,524F4F54,433A2F446
 *   F63756D656E747320616E642053657474696E67732F416E646
 *   5727320526F7376616C6C2F4D696E6120646F6B756D656E742
 *   F456D62656464656420417274697374732F50726F647563747
 *   32F4C50433231303620525332333220517569636B537461727
 *   420426F6172642F72746F732F]505245464958,,4445425547
 *   5F4C4556454C,30,555345525F434F4D4D454E54,]64656661
 *   756C74,
 *
 * Checksum:
 *    1257472
 *
 *****************************************************************************/


/******************************************************************************
 * Includes
 *****************************************************************************/

#include "kernel.h"
#include "hal.h"
#include "pcb.h"
#include "error.h"
#include "prioqueue.h"
#include "../stub/osstub.h"
#include "../api/general.h"
#include "timer.h"

#include "stack_usage.h"



/******************************************************************************
 * Public variables
 *****************************************************************************/

tOSPCB *pRunProc = NULL;        /* currently running process */
tOSPCB *pNxtToRun = NULL;       /* next process to run during context switch */
tU8 isrNesting = 0;             /* increased for every ISR enter and
                                   decreased for every ISR leave */
tU8 osLockNesting = 0;          /* This variable is used to lock the
                                   scheduler */
tOSPCB processControlBlocks[MAX_NUM_PROC];

/******************************************************************************
 * Local variables
 *****************************************************************************/

static tPrioQueue rdyQueue;
static tOSPCB *pTimeList = NULL;
static tBool osRunning = FALSE;


/******************************************************************************
 * Local functions
 *****************************************************************************/

/******************************************************************************
 * Implementation of public functions
 *****************************************************************************/


/*****************************************************************************
 *
 * Description:
 *    This function returns the process identification descriptor for the 
 *    running process. 
 *
 * Params:
 *    [out] pError - The return status of the function. 
 *
 * Returns:
 *    The process identification descriptor of the currently running process. 
 *
 * Error codes:
 *    OS_OK        - The function completed successfully. 
 *    OS_ERROR_ISR - The function was called from an interrupt service 
 *                   routine. 
 *
 ****************************************************************************/
tU8
osPid(tU8* pError)
{
  volatile tSR localSR;  /* declare temporary local space for status word */

  tU8 pid;
  m_os_dis_int();

  *pError = OS_OK;
  if(isrNesting > 0)
  {
    m_os_ena_int();
    *pError = OS_ERROR_ISR;

    return 0;
  }

  pid = pRunProc->pid;  
  m_os_ena_int();
  return pid;
}


/*****************************************************************************
 *
 * Description:
 *    This function puts a process to sleep for the specified number of ticks. 
 *
 * Params:
 *    [in] ticks - The number of ticks to put the process to sleep. 
 *
 ****************************************************************************/
void
osSleep(tU32 ticks)
{
  volatile tSR localSR;  /* declare temporary local space for status word */

  if(ticks > 0)
  {
    m_os_dis_int();
    pRunProc->sleep = ticks;
    rmvFromRdyList();
    addToTimeList();
    m_os_ena_int();
    schedule();
  }
}


/*****************************************************************************
 *
 * Description:
 *    This function must be called before any other call to the operating 
 *    system. 
 *
 ****************************************************************************/
void
osInit(void)
{
  tU16 i;
  for(i=0; i<MAX_NUM_PROC; i++)
  {
     processControlBlocks[i].flag = 0;
  }
  initPrioQueue(&rdyQueue, processControlBlocks);
}


/*****************************************************************************
 *
 * Description:
 *    This function starts the operating system. There must be at least one 
 *    process created and started before this function is called. A process is 
 *    created by calling osCreateProcess and started by calling 
 *    osStartProcess. osStart, osCreateProcess and osStartProcess are the only 
 *    operating system functions that may be called before the operating 
 *    system is started. If other operating system functions are called before 
 *    the operating system is started the behavior is undefined. The preferred 
 *    way of starting up a multitasking system is to only create and start an 
 *    init process in the main function before osStart is called. The init 
 *    process initializes the system and starts other processes needed. The 
 *    init process can safely initialize other operating system objects like 
 *    semaphores, queues, etc. 
 *
 ****************************************************************************/
void
osStart(void)
{
  volatile tSR localSR = 0;  /* declare temporary local space for status word */


  m_os_dis_int();
  osRunning = TRUE;
  m_os_init_hal();
  osGetHighPrioProc();
  m_os_start_high_proc();
}


/*****************************************************************************
 *
 * Description:
 *    This function is used to notify the operating system that the 
 *    application has entered an interrupt service routine (ISR). This is 
 *    important if the ISR is using services from the operating system, since 
 *    some services need to know if they are executed from an ISR or not. The 
 *    function osISRExit should be used before the ISR returns to 
 *    notify the operating system about the ISR exit. 
 *
 ****************************************************************************/
void
osISREnter(void)
{
  if (osRunning == TRUE)
  {
    if (isrNesting < 255)
      isrNesting++;
  }
}


/*****************************************************************************
 *
 * Description:
 *    This function is used to notify the operating system that the currently 
 *    serviced interrupt is about to exit. The function is always used in 
 *    conjunction with the function osISREnter, which should always 
 *    be called before osISRExit. It is important to notify the OS 
 *    about ISRs (Interrupt Service Routines) if they are using services from 
 *    the operating system (since some services need to know if they are 
 *    executed from an ISR or not). 
 *
 ****************************************************************************/
void
osISRExit(void)
{
  volatile tSR localSR;  /* declare temporary local space for status word */

  if (osRunning == TRUE)
  {
    m_os_dis_int();
    
    if (isrNesting > 0)
      isrNesting--;

    if ((osLockNesting == 0) && (isrNesting == 0))
    {
      osGetHighPrioProc();
      if ((pRunProc != pNxtToRun) && (pNxtToRun != NULL))
      {
        m_os_isr_ctx_switch();
      }
    }
    m_os_ena_int();
  }
}


/*****************************************************************************
 *
 * Description:
 *    This function deletes the currently running process. The process control 
 *    block used by the process will be freed and is therefore available for 
 *    new processes. 
 *
 ****************************************************************************/
void
osDeleteProcess(void)
{
  volatile tSR localSR;  /* declare temporary local space for status word */

  m_os_dis_int();
  rmvFromRdyList();
  pRunProc->flag = 0;
  m_os_ena_int();
  schedule();
}



/*****************************************************************************
 *
 * Description:
 *    This function creates a new process. The process is not automatically 
 *    started. To start the process the osStartProcess function must be 
 *    called. A new process can only be created if there is a free process 
 *    control block available. The number of process control blocks is 
 *    specified during operating system configuration (maximum number of 
 *    processes). 
 *
 * Params:
 *    [in]  pProc   - The process entry function. 
 * 
 *              Params (callback):
 *                 arg - This argument can be used to pass arbitrary 
 *                       information to the process entry function when the 
 *                       process is started. 
 *    [in]  pStk    - A pointer to the stack area to use. The stack area must 
 *                    be allocated before the process is created. 
 *    [in]  stkSize - The size of the stack area in bytes. 
 *    [out] pPid    - The returned process identification descriptor (pid). 
 *    [in]  prio    - The priority of the process. The priority is a number 
 *                    between 0 and NUM_PRIO-1, where NUM_PRIO is specified 
 *                    during operating system configuration (maximum number of 
 *                    priorities). 0 is the highest priority level and 
 *                    NUM_PRIO-1 is the lowest priority level. The operating 
 *                    system will always run the process that has the highest 
 *                    priority and is ready to run, i.e. is not sleeping, 
 *                    suspended or waiting for a synchronization primitive. If 
 *                    several processes are run on the same priority level 
 *                    they are scheduled in a round-robin fashion. 
 *    [in]  pParam  - This parameter is passed to the process entry function 
 *                    when the process is started. 
 *    [out] pError  - The return status of the function. 
 *
 * Error codes:
 *    OS_OK             - The function completed successfully. 
 *    OS_ERROR_PRIO     - The supplied priority is not correct. 
 *    OS_ERROR_ALLOCATE - The process could not be created since there are no 
 *                        free process control blocks available. The number of 
 *                        process control blocks is specified during operating 
 *                        system configuration (maximum number of processes). 
 *
 ****************************************************************************/
void
osCreateProcess(void  (*pProc) (void* arg),
                tU8*  pStk,
                tU16  stkSize,
                tU8*  pPid,
                tU8   prio,
                void* pParam,
                tU8*  pError)
{
  tOSPCB *pPCB;
  tU8 pid;

  *pError = OS_OK;
  if(prio >= NUM_PRIO)
  {
    *pError = OS_ERROR_PRIO;

      return;
  }
  for(pid = 0; 
      pid < MAX_NUM_PROC; 
      pid++)
  {
    if(processControlBlocks[pid].flag == 0)
      break;
  }
  if(pid == MAX_NUM_PROC)
  {
    *pError = OS_ERROR_ALLOCATE;

    return;
  }

  pPCB  = &processControlBlocks[pid];


  pPCB->pStkOrg = pStk;
  pPCB->stackSize = stkSize;
  createStackPattern(pStk, stkSize);


  pStk = pStk + stkSize;                        /* stack grows from high to low memory */
  pStk = (tU8*)((tU32)pStk & 0xFFFFFFFC);       /* 4 byte alignment */


  pPCB->pStk = m_os_stk_frame_init(pProc, 
                                pStk, 
                                pParam, 
                                NULL);

  pPCB->pid = pid;
  *pPid = pid;
  pPCB->sleep = 0;
  pPCB->flag = (tU8)PROC_ENDED;
  pPCB->pNextPrioQueueReady = NULL;
  pPCB->pPrevPrioQueueReady = NULL;
  pPCB->pNextPrioQueueEvent = NULL;
  pPCB->pPrevPrioQueueEvent = NULL;

  pPCB->pNextTimeQueue = NULL;
  pPCB->prio = prio;
}


/*****************************************************************************
 *
 * Description:
 *    This function is used to start a process. The process must previously 
 *    have been created by a call to osCreateProcess. 
 *
 * Params:
 *    [in]  pid    - The process identification descriptor (pid) of the 
 *                   process to start. The pid is returned by osCreateProcess. 
 *    [out] pError - The return status of the function. 
 *
 * Error codes:
 *    OS_OK        - The function completed successfully. 
 *    OS_ERROR_PID - The supplied pid is not correct. 
 *
 ****************************************************************************/
void
osStartProcess(tU8  pid,
               tU8* pError)
{
  volatile tSR localSR = 0;  /* declare temporary local space for status word */

  *pError = OS_OK;
  if(pid >= MAX_NUM_PROC)
  {
    *pError = OS_ERROR_PID;

    return;
  }
  if(processControlBlocks[pid].flag != PROC_ENDED)
  {
    *pError = OS_ERROR_PID;

    return;
  }

  if(osRunning == TRUE)
  {
    m_os_dis_int();
  }

  processControlBlocks[pid].flag = (tU8)PROC_ACTIVE;
  addToRdyList(&processControlBlocks[pid]);

  if(osRunning == TRUE)
  {
    m_os_ena_int();
    schedule();
  }
}


/*****************************************************************************
 *
 * Description:
 *    This function must be called periodically, usually from a timer 
 *    interrupt, to generate a system tick. It is essential to the operating 
 *    system to receive a periodic tick to work at all. All times in the 
 *    operating system is measured in system ticks, i.e. the time between two 
 *    system ticks. 
 *
 ****************************************************************************/
void
osTick(void)
{
  volatile tSR localSR;  /* declare temporary local space for status word */
  tOSPCB *pMove;
  m_os_dis_int();
  if(pTimeList != NULL)
  {
    pTimeList->sleep--;
    while(pTimeList->sleep == 0)
    {
      pMove = pTimeList;
      pTimeList = pMove->pNextTimeQueue;
      pMove->flag &= ~(tU8)PROC_SLEEP;
      addToRdyList(pMove);
      if(pTimeList == NULL)
        break;
    }
  }
  m_os_ena_int();
  timerTick();

  m_os_user_tick();
}


/*****************************************************************************
 *
 * Description:
 *    This function suspends the currently running process. Another process 
 *    can resume it by a call to osResume. 
 *
 ****************************************************************************/
void
osSuspend(void)
{
  volatile tSR localSR;  /* declare temporary local space for status word */

  m_os_dis_int();
  pRunProc->flag |= (tU8)PROC_SUSPENDED;
  rmvFromRdyList();
  m_os_ena_int();
  schedule();
}


/*****************************************************************************
 *
 * Description:
 *    This function resumes a suspended process. It is valid to do resume on a 
 *    process that has not been suspended. 
 *
 * Params:
 *    [in]  pid    - The process to resume. 
 *    [out] pError - The return status of the function. 
 *
 * Error codes:
 *    OS_OK        - The function completed successfully. 
 *    OS_ERROR_PID - The supplied pid is not correct. 
 *
 ****************************************************************************/
void
osResume(tU8  pid,
         tU8* pError)
{
  volatile tSR localSR;  /* declare temporary local space for status word */

  *pError = OS_OK;
  if(pid >= MAX_NUM_PROC)
  {
    *pError = OS_ERROR_PID;

    return;
  }

  m_os_dis_int();
  if(((processControlBlocks[pid].flag) & PROC_SUSPENDED) == 0)
  {
    m_os_ena_int();
    return;
  }

  processControlBlocks[pid].flag &= ~(tU8)PROC_SUSPENDED;
  addToRdyList(&processControlBlocks[pid]);
  if(isrNesting == 0)
  {
    m_os_ena_int();
    schedule();
  }
  else
    m_os_ena_int();
}


/*****************************************************************************
 *
 * Description:
 *    This function makes a context switch if there is a process with higher 
 *    or equal priority to the one already running. 
 *
 ****************************************************************************/
void
schedule(void)
{
  volatile tSR localSR;  /* declare temporary local space for status word */

  m_os_dis_int();
  if(osLockNesting == 0)
  {
    wakefromidle:
    osGetHighPrioProc();
    if(pNxtToRun == NULL)
    {
      osLockNesting++;
      m_os_ena_int();
      m_os_idle();
      m_os_dis_int();
      osLockNesting--;
      goto wakefromidle;
    }
    if(pNxtToRun != pRunProc)
    {
      m_os_ctx_switch();
    }
  }
  m_os_ena_int();
}


/*****************************************************************************
 *
 * Description:
 *    This function implements the scheduling policy and modifies the 
 *    pNxtToRun pointer to point to the process that should run according to 
 *    the policy. The policy is to always run the process with the highest 
 *    priority that is ready to run. If there is more than one process with 
 *    the highest priority, the processes are scheduled in a round-robin 
 *    fashion. 
 *
 ****************************************************************************/
void
osGetHighPrioProc(void)
{
  pNxtToRun = getHighPrioQueue(&rdyQueue, READY_QUEUE);
}


/*****************************************************************************
 *
 * Description:
 *    This function adds a process to the time-list. The time-list contains 
 *    processes suspended for a certain amount of time. As times expire they 
 *    are put back to the ready-list. The function operates on the currently 
 *    running process. 
 *
 ****************************************************************************/
void
addToTimeList(void)
{
  tOSPCB * pPCB = NULL;
  tOSPCB * pPrev = NULL;

  pRunProc->flag |= (tU8)PROC_SLEEP;

  if(pTimeList == NULL)
  {
    pTimeList = pRunProc;
    pRunProc->pNextTimeQueue = NULL;    
  }
  else
  {
    for(pPCB = pTimeList;
        pPCB != NULL;
        pPCB = pPCB->pNextTimeQueue)
    {
      if(pRunProc->sleep <= pPCB->sleep)
      {
        break;
      }
      pRunProc->sleep -= pPCB->sleep;
      pPrev = pPCB;
    }
    /* insert pRunProc between pPrev and pPCB */

    pRunProc->pNextTimeQueue = pPCB;
    
    if(pPrev != NULL)
      pPrev->pNextTimeQueue = pRunProc;
    else
      pTimeList = pRunProc;
    
    if(pPCB != NULL)
      pPCB->sleep -= pRunProc->sleep; /* update relative sleep time */
  }  
}


/*****************************************************************************
 *
 * Description:
 *    This function removes a process from the time-list. 
 *
 * Params:
 *    [in] pPCB - A pointer to the process control block of the process to 
 *                remove. 
 *
 ****************************************************************************/
void
rmvFromTimeList(tOSPCB* pPCB)
{
  tOSPCB * pTimePCB = NULL;
  tOSPCB * pPrev = NULL;

  pPCB->flag &= ~(tU8)PROC_SLEEP;
  
  for(pTimePCB = pTimeList;
      pTimePCB != NULL;
      pTimePCB = pTimePCB->pNextTimeQueue)
  {
    if(pTimePCB == pPCB)
    {
      if(pPrev == NULL)
      {
        pTimeList = pTimePCB->pNextTimeQueue;
      }
      else
      {
        pPrev->pNextTimeQueue = pTimePCB->pNextTimeQueue;
      }
      if(pTimePCB->pNextTimeQueue != NULL)
      {
        pTimePCB->pNextTimeQueue->sleep += pTimePCB->sleep; /* update relative time */
      }
      break;
    }
    pPrev = pTimePCB;
  }
}


/*****************************************************************************
 *
 * Description:
 *    This function adds a process to the ready-list. 
 *
 * Params:
 *    [in] pMove - A pointer to the process control block to add. 
 *
 ****************************************************************************/
void
addToRdyList(tOSPCB* pMove)
{
  addToPrioQueue(&rdyQueue, pMove, READY_QUEUE);
}


/*****************************************************************************
 *
 * Description:
 *    This function removes the currently running process from the ready-list. 
 *
 ****************************************************************************/
void
rmvFromRdyList(void)
{
  rmvFromPrioQueue(&rdyQueue, pRunProc, READY_QUEUE);
}

/******************************************************************************
 * Implementation of local functions
 *****************************************************************************/
